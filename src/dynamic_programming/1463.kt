package dynamic_programming

import kotlin.math.min

/**
 * 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
 *
 * X가 3으로 나누어 떨어지면, 3으로 나눈다.
 * X가 2로 나누어 떨어지면, 2로 나눈다.
 * 1을 뺀다.
 * 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
 *
 * 입력
 * 첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.
 *
 * 출력
 * 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
 *
 * 예제 입력 1
 * 2
 * 예제 출력 1
 * 1
 * 예제 입력 2
 * 10
 * 예제 출력 2
 * 3
 * */


fun `1463-1로 만들기`(){
    val br = System.`in`.bufferedReader()
    val bw = System.out.bufferedWriter()
    val n = br.readLine().toInt()
    // DP 테이블 생성 (인덱스를 1부터 사용하기 위해 n+1 크기)
    val dp = IntArray(n + 1)
    // dp[0] 은 미사용. dp[1] 은 1 자체이므로 연산 0번
    // Bottom-up 방식으로 2부터 N까지 DP 테이블 채워나가기
    for (i in 2..n) {
        // (-1) 연산: 바로 이전 숫자의 경우에서 1을 더한 것이 기본값
        dp[i] = dp[i - 1] + 1 // i 가 2인 경우 dp[1] + 1 이므로 0 + 1 하여 1 번.

        // (/2) 연산: i가 2로 나누어 떨어지면,
        // 기존 값과 (i/2에서 1로 만드는 횟수 + 1)을 비교하여 더 작은 값을 선택
        if (i % 2 == 0) {
            dp[i] = min(dp[i], dp[i / 2] + 1)
        }

        // (/3) 연산: i가 3으로 나누어 떨어지면,
        // 기존 값과 (i/3에서 1로 만드는 횟수 + 1)을 비교하여 더 작은 값을 선택
        if (i % 3 == 0) {
            dp[i] = min(dp[i], dp[i / 3] + 1)
        }
    }

    bw.write(dp[n].toString())
    bw.flush()
    bw.close()
    br.close()
}